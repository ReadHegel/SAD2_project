---
title: "sad"
author: "Marcin Stopka, Franciszek Sobota, Grzegorz Dolanowski"
date: "2026-01-10"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

#install.packages("here")
#install.packages("ggplot2")
#install.packages("dplyr")
#install.packages("GGally")
#install.packages("fastDummies")
#install.packages("broom")

library(here)
library(ggplot2)
library(dplyr)
library(GGally)
library(fastDummies)
library(knitr)
library(broom)

data <- read.csv(here("task1", "all_data.csv"))

```

# Effect of sampling frequency

We can see on the plots that if time between sampling increases, the results get worse.
```{r}
ggplot(data, aes(x=factor(freq), y=jaccard_result)) +
  geom_violin()
```

We can test if the correlation is negative and we get
```{r}
tst <- cor.test(data$freq, data$jaccard_result, method = "spearman")
tst
```
with low p-value of `r tst$p.value``.

# Graph Metrics

We can see that the two graph metrics are very similar on the following plot.
```{r}
ggplot(data, aes(x=jaccard_result, y=jaccard_weighted_result)) + geom_point()
```

# Achieved results

The summary of the achieved results can be seen in the following table
```{r}
kable(data.frame(rbind(summary(data$jaccard_result))))
```
and a violin plot of all results looks as follows. We can see that it is rather bottom heavy, but there are also high results present.
```{r}
ggplot(data, aes(x="", y=jaccard_result)) +
  geom_violin()
```


# Effect of number of variables

As we add more variables, the results become worse.
```{r}
ggplot(data, aes(x=factor(var_num), y=jaccard_result)) +
  geom_violin()
```

as can be seen in the correlation test
```{r}
tst <- cor.test(data$var_num, data$jaccard_result, method = "spearman")
tst
```
with low p-value of `r tst$p.value`.

# Effect of mode

First we can see that the synchronous data is much less resistant to infrequent probes.
```{r}
ggplot(data, aes(x=mode,y=factor(steps),fill=jaccard_result)) + geom_tile() + facet_wrap(~freq)
```
The asynchronous can sort of deal with it, but synchronous works very bad whenever sampling frequency is not 1.

We can see on the following plot that if the frequency is 1, then synchronous data gives generally better results with the given amount of data. It can be because with the same number of transitions more variables get changed.
```{r}
ggplot(data %>% filter(freq==1), aes(x=mode, y=jaccard_result)) +
  geom_violin()
```

If we divide the data by number of variables we can see that with frequency 1, every time the synchronous option is better.
```{r}
ggplot(data %>% filter(freq==1), aes(x=mode,y=factor(steps),fill=jaccard_result)) + geom_tile() +
    facet_wrap(~var_num)
```

# Scoring mode

As we can see here, the scoring mode has little to no effect on the result given other parameters.
```{r}
ggplot(data, aes(x=mode,y=score_type,fill=jaccard_result)) +
  geom_tile() +
  facet_grid(freq~steps)
```

We can also use Kolmogorov-Smirnov test to check if they give the same distributions and it gives us that we cannot rule that out with any sensible confidence.
```{r}
ks.test((data %>% filter(score_type=='MDL'))$jaccard_result,
        (data %>% filter(score_type=='BDE'))$jaccard_result)
```

# Effect of attractor frequency
We can very reasonably conclude, that when using synchronous data, attractor percentage has negative effect.
```{r}
data_synch <- data %>% filter(mode=="synchronous")
tst <- cor.test(data_synch$attper, data_synch$jaccard_result, method = "spearman")
tst
```
with a low p-value of `r tst$p.value``. On the other hand, in asynchronous data it has the opposite effect.
```{r}
data_asynch <- data %>% filter(mode=="asynchronous")
tst <- cor.test(data_asynch$attper, data_asynch$jaccard_result, method = "spearman")
tst
```
again with a low p-value of `r tst$p.value``

# Linear regression

If we fun linear regression with all the data, it doesn't work the best, gives adjusted R squared of `r summary(lm(jaccard_result ~ var_num + steps + numtraj + attper + mode_synchronous + score_type_BDE, dummy_cols(data)))$adj.r.squared` On the other hand, if we filter only by those results that have frequency 1, we get a high R squared.
```{r}
data_with_dummies <- dummy_cols(data) %>% filter(freq==1)
linear_model <- lm(jaccard_result ~
                      var_num + steps + numtraj + attper + mode_synchronous + score_type_BDE,
                      data_with_dummies)

kable(tidy(linear_model))
```
And with data filtered by frequency equal to 1, we get adjusted R squared of `r summary(linear_model)$adj.r.squared`.
